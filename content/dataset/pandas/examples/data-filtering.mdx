# Pandas 예제문제 1 - 데이터 필터링

## 문제 설명

다양한 조건을 이용하여 DataFrame의 데이터를 필터링하는 방법을 학습하시오.

## 데이터 준비

```python
import pandas as pd
import numpy as np

# 샘플 데이터 생성
np.random.seed(42)
n = 100

data = {
    'name': [f'학생{i+1}' for i in range(n)],
    'age': np.random.randint(18, 25, n),
    'gender': np.random.choice(['남', '여'], n),
    'department': np.random.choice(['컴퓨터과학', '경영학', '수학', '물리학'], n),
    'grade': np.random.choice(['1학년', '2학년', '3학년', '4학년'], n),
    'score': np.random.normal(75, 15, n).round(1),
    'attendance': np.random.uniform(0.7, 1.0, n).round(2),
    'scholarship': np.random.choice([True, False], n, p=[0.3, 0.7])
}

df = pd.DataFrame(data)
print("데이터 기본정보:")
print(df.head())
print(f"\n데이터 크기: {df.shape}")
print(f"\n데이터 타입:")
print(df.dtypes)
```

## 문제 1: 기본 필터링

**Q1-1.** 점수가 80점 이상인 학생들을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 점수가 80점 이상인 학생 필터링
high_score_students = df[df['score'] >= 80]
print(f"80점 이상 학생 수: {len(high_score_students)}명")
print("\n80점 이상 학생 목록:")
print(high_score_students[['name', 'score', 'department']].head())

# 조건을 만족하는 학생 비율
percentage = (len(high_score_students) / len(df)) * 100
print(f"\n전체 학생 중 80점 이상: {percentage:.1f}%")
```
</CollapsibleCodeCell>

**Q1-2.** 컴퓨터과학과 학생들만 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 컴퓨터과학과 학생 필터링
cs_students = df[df['department'] == '컴퓨터과학']
print(f"컴퓨터과학과 학생 수: {len(cs_students)}명")
print("\n컴퓨터과학과 학생 정보:")
print(cs_students[['name', 'age', 'grade', 'score']].head())

# 컴퓨터과학과 평균 점수
cs_avg_score = cs_students['score'].mean()
print(f"\n컴퓨터과학과 평균 점수: {cs_avg_score:.1f}점")
```
</CollapsibleCodeCell>

## 문제 2: 복합 조건 필터링

**Q2-1.** 점수가 80점 이상이면서 출석률이 90% 이상인 학생을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 복합 조건: 점수 80점 이상 AND 출석률 90% 이상
excellent_students = df[(df['score'] >= 80) & (df['attendance'] >= 0.9)]
print(f"우수 학생(점수80+ & 출석률90%+) 수: {len(excellent_students)}명")
print("\n우수 학생 목록:")
print(excellent_students[['name', 'score', 'attendance', 'department']].head())

# 학과별 우수 학생 분포
dept_distribution = excellent_students['department'].value_counts()
print(f"\n학과별 우수 학생 분포:")
print(dept_distribution)
```
</CollapsibleCodeCell>

**Q2-2.** 1학년이거나 4학년인 학생들을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# OR 조건: 1학년 또는 4학년
freshman_senior = df[(df['grade'] == '1학년') | (df['grade'] == '4학년')]
print(f"1학년 또는 4학년 학생 수: {len(freshman_senior)}명")

# 학년별 분포
grade_distribution = freshman_senior['grade'].value_counts()
print(f"\n학년별 분포:")
print(grade_distribution)

# 학년별 평균 점수 비교
grade_stats = freshman_senior.groupby('grade')['score'].agg(['mean', 'std', 'count'])
print(f"\n학년별 점수 통계:")
print(grade_stats.round(2))
```
</CollapsibleCodeCell>

## 문제 3: isin() 메서드 활용

**Q3-1.** 특정 학과(컴퓨터과학, 수학) 학생들을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# isin() 메서드로 여러 값 필터링
target_depts = ['컴퓨터과학', '수학']
stem_students = df[df['department'].isin(target_depts)]
print(f"STEM 학과 학생 수: {len(stem_students)}명")

# 학과별 상세 정보
dept_summary = stem_students.groupby('department').agg({
    'score': ['mean', 'min', 'max'],
    'attendance': 'mean',
    'scholarship': 'sum'
}).round(2)

print(f"\n학과별 요약 정보:")
print(dept_summary)

# 각 학과의 상위 5명 학생
print(f"\n각 학과 상위 5명:")
for dept in target_depts:
    dept_data = stem_students[stem_students['department'] == dept]
    top5 = dept_data.nlargest(5, 'score')
    print(f"\n{dept}과 TOP 5:")
    print(top5[['name', 'score', 'attendance']].to_string(index=False))
```
</CollapsibleCodeCell>

## 문제 4: 문자열 필터링

**Q4-1.** 이름에 특정 문자가 포함된 학생을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 문자열 포함 조건
students_with_5 = df[df['name'].str.contains('5')]
print(f"이름에 '5'가 포함된 학생 수: {len(students_with_5)}명")
print("\n해당 학생들:")
print(students_with_5[['name', 'score', 'department']].head())

# 정규식을 이용한 필터링 (이름이 '학생1'로 시작하는 경우)
regex_pattern = r'^학생1'
students_pattern = df[df['name'].str.match(regex_pattern)]
print(f"\n이름이 '학생1'로 시작하는 학생 수: {len(students_pattern)}명")
print(students_pattern[['name', 'score']].head())
```
</CollapsibleCodeCell>

## 문제 5: 결측값 필터링

**Q5-1.** 결측값이 없는 완전한 데이터만 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 인위적으로 결측값 생성 (시연용)
df_with_na = df.copy()
# 랜덤하게 일부 데이터를 NaN으로 설정
na_indices = np.random.choice(df_with_na.index, 10, replace=False)
df_with_na.loc[na_indices, 'score'] = np.nan

print("결측값 확인:")
print(df_with_na.isnull().sum())

# 결측값이 없는 행만 필터링
complete_data = df_with_na.dropna()
print(f"\n완전한 데이터 행 수: {len(complete_data)}개")
print(f"제거된 행 수: {len(df_with_na) - len(complete_data)}개")

# 특정 컬럼에 결측값이 없는 경우
score_not_null = df_with_na[df_with_na['score'].notna()]
print(f"\n점수가 결측이 아닌 학생 수: {len(score_not_null)}명")
```
</CollapsibleCodeCell>

## 문제 6: query() 메서드 활용

**Q6-1.** query() 메서드를 사용하여 복합 조건 필터링을 수행하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# query() 메서드를 이용한 필터링
# 조건: 나이 20세 이상, 점수 70점 이상, 장학금 수혜자
query_result = df.query("age >= 20 and score >= 70 and scholarship == True")
print(f"조건을 만족하는 학생 수: {len(query_result)}명")
print("\n해당 학생들:")
print(query_result[['name', 'age', 'score', 'scholarship']].head())

# 더 복잡한 query 조건
complex_query = df.query("department in ['컴퓨터과학', '수학'] and grade in ['3학년', '4학년'] and score > 80")
print(f"\n복합 조건 학생 수: {len(complex_query)}명")

# 학과별 분석
if len(complex_query) > 0:
    dept_analysis = complex_query.groupby('department')['score'].describe()
    print(f"\n학과별 점수 분석:")
    print(dept_analysis.round(2))
```
</CollapsibleCodeCell>

## 문제 7: 분위수 기반 필터링

**Q7-1.** 점수 상위 25%에 해당하는 학생들을 조회하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 분위수 계산
q75 = df['score'].quantile(0.75)
q25 = df['score'].quantile(0.25)
median = df['score'].median()

print(f"점수 분위수 정보:")
print(f"25분위수 (Q1): {q25:.1f}점")
print(f"50분위수 (중앙값): {median:.1f}점")
print(f"75분위수 (Q3): {q75:.1f}점")

# 상위 25% 학생 필터링
top_25_percent = df[df['score'] >= q75]
print(f"\n상위 25% 학생 수: {len(top_25_percent)}명")

# 하위 25% 학생 필터링
bottom_25_percent = df[df['score'] <= q25]
print(f"하위 25% 학생 수: {len(bottom_25_percent)}명")

# 상위 25%와 하위 25% 학생들의 학과 분포 비교
print(f"\n상위 25% 학과 분포:")
print(top_25_percent['department'].value_counts())

print(f"\n하위 25% 학과 분포:")
print(bottom_25_percent['department'].value_counts())

# IQR을 이용한 이상치 탐지
iqr = q75 - q25
outlier_threshold_high = q75 + 1.5 * iqr
outlier_threshold_low = q25 - 1.5 * iqr

outliers = df[(df['score'] > outlier_threshold_high) | (df['score'] < outlier_threshold_low)]
print(f"\n이상치 학생 수: {len(outliers)}명")
if len(outliers) > 0:
    print("이상치 학생들:")
    print(outliers[['name', 'score', 'department']])
```
</CollapsibleCodeCell>

## 문제 8: 조건부 집계

**Q8-1.** 각 조건별로 학생 수와 평균 점수를 집계하시오.

<CollapsibleCodeCell language="python" defaultCollapsed={true}>
```python
# 성별 조건부 집계
gender_stats = df.groupby('gender').agg({
    'score': ['count', 'mean', 'std'],
    'attendance': 'mean',
    'scholarship': 'sum'
}).round(2)

print("성별 집계:")
print(gender_stats)

# 학과별 조건부 집계
dept_stats = df.groupby('department').agg({
    'score': ['count', 'mean', 'std'],
    'attendance': 'mean',
    'scholarship': 'sum'
}).round(2)

print(f"\n학과별 집계:")
print(dept_stats)

# 점수 구간별 집계
df['score_range'] = pd.cut(df['score'],
                          bins=[0, 60, 70, 80, 90, 100],
                          labels=['F(0-60)', 'D(60-70)', 'C(70-80)', 'B(80-90)', 'A(90-100)'])

grade_distribution = df['score_range'].value_counts().sort_index()
print(f"\n성적 구간별 분포:")
print(grade_distribution)

# 성적 구간별 장학금 수혜율
scholarship_by_grade = df.groupby('score_range')['scholarship'].agg(['count', 'sum', 'mean']).round(3)
scholarship_by_grade.columns = ['총인원', '장학금수혜자', '수혜율']
print(f"\n성적 구간별 장학금 수혜 현황:")
print(scholarship_by_grade)
```
</CollapsibleCodeCell>

## 종합 정리

:::note[학습 요약]
이 예제에서 다룬 주요 내용:

1. **기본 필터링**: 단일 조건으로 데이터 선택
2. **복합 조건**: &(and), |(or) 연산자 활용
3. **isin() 메서드**: 여러 값에 대한 필터링
4. **문자열 필터링**: contains(), match() 메서드
5. **결측값 처리**: dropna(), notna() 활용
6. **query() 메서드**: SQL-like 문법으로 필터링
7. **분위수 기반**: quantile() 활용한 구간 설정
8. **조건부 집계**: groupby()와 agg() 조합
:::

:::warning[필터링 주의사항]
- **체이닝 주의**: 여러 조건을 연결할 때 괄호 사용 필수
- **데이터 타입**: 필터링 전 데이터 타입 확인 중요
- **성능 고려**: 대용량 데이터에서는 query() 메서드가 더 효율적
- **결측값 처리**: 비교 연산 시 NaN 값 고려 필요
:::

## 참고자료

- Pandas 공식 문서 - Indexing and Selecting Data
- 『파이썬 라이브러리를 활용한 데이터 분석』, 웨스 맥키니